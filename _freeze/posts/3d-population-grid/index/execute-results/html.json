{
  "hash": "efa60557eaca6b9e4af142e3a754d8ea",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"3D population density mapping\"\nauthor: \"Isaac Bain\"\ndate: \"2024-07-04\"\ncategories: [code, population, maps]\nexecute:\n  warning: false\n  error: false\n  messages: false\nformat: \n  html:\n    code-fold: true\n    code-summary: \"Show the code\"\n    toc: true\n    toc-location: left\n    number-sections: true\neditor: visual\nlightbox: auto\n---\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(rgl.useNULL = TRUE)\nrgl::setupKnitr(autoprint = TRUE)\n```\n:::\n\n\n## Introduction\n\n3D maps can be both informative and visually stunning. I recently created some 3D population density maps for New Zealand using the R package `rayshader`, mainly because they look cool! Let’s dive into how these maps were made and what they show.\n\nFor more details on this same population grid, see my previous [post](https://isaacbain.com/posts/population-grid/).\n\n## Data and methods\n\nFor these maps, I used the 2022 Estimated Resident Population Grid data for New Zealand. With R and the awesome `rayshader` package, I transformed this data into 3D visualisations that really pop. `Rayshader` makes it super easy to add depth and perspective, turning flat data into eye-catching 3D landscapes.\n\nI have to give credit to this [Medium](https://medium.com/@niloy.swe/how-to-create-a-3d-population-density-map-in-r-33dfaf7a71d7) post and sherifscript's GitHub [repo](https://github.com/sherifscript/RayshaderMaps) for providing inspiration for most of the code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# libraries\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(koordinatr)\nlibrary(stars)\nlibrary(rayshader)\nlibrary(rayrender)\nlibrary(magick)\n\n# import data \n# 1km population grid\ndat <- koordinatr::get_layer_as_sf(api_key = Sys.getenv(\"koordinates_api_key\"),\n                                   agency = \"statsnz\",\n                                   id = \"115051\")\n\n# set bounding box for mainland nz\nmainland_bbox_nztm <- st_bbox(c(xmin = 1060000, ymin = 4700000, xmax = 2080000, ymax = 6300000), crs = st_crs(2193))\n\n# crop the sf object to the bounding box\ndat <- st_crop(dat, mainland_bbox_nztm)\n\n# get the bounding box of the final data\nbbox <- st_bbox(dat)\n\n# finding the aspect ratio\nbottom_left <- st_point(c(bbox[[\"xmin\"]], bbox[[\"ymin\"]])) %>%\n  st_sfc(crs = 2193)\nbottom_right <- st_point(c(bbox[[\"xmax\"]], bbox[[\"ymin\"]])) %>%\n  st_sfc(crs = 2193)\ntop_left <- st_point(c(bbox[[\"xmin\"]], bbox[[\"ymax\"]])) %>%\n  st_sfc(crs = 2193)\ntop_right <- st_point(c(bbox[[\"xmin\"]], bbox[[\"ymax\"]])) %>%\n  st_sfc(crs = 2193)\n\n# calculate width and height\nwidth <- st_distance(bottom_left, bottom_right)\nheight <- st_distance(bottom_left, top_left)\n\n# calculate aspect ratio\nif(width > height) {\n  w_ratio = 1\n  h_ratio = height / width\n  \n} else {\n  h_ratio = 1.1\n  w_ratio = width / height\n}\n\n# convert to raster to convert to matrix\nsize = 1000 * 3.5\n\npop_raster <- st_rasterize(\n  dat,\n  nx = floor(size * w_ratio) %>% as.numeric(),\n  ny = floor(size * h_ratio) %>% as.numeric()\n)\n\npop_matrix <- matrix(pop_raster$ERP_2022,\n                     nrow = floor(size * w_ratio),\n                     ncol = floor(size * h_ratio))\n\n# setup colour palette\ncolor <- MetBrewer::met.brewer(name = \"Benedictus\", direction = -1)\n\ntx <- grDevices::colorRampPalette(color, bias = 4.5)(256)\ncolorspace::swatchplot(tx)\n```\n\n```{.r .cell-code}\n# create the 3d plot\npop_matrix %>%\n  height_shade(texture = tx) %>%\n  plot_3d(heightmap = pop_matrix,\n          zscale = 20,\n          solid = F,\n          shadowdepth = 0)\n\n# adjusting camera angle for oblique view\nrender_camera(theta = 0,\n              phi = 30,\n              zoom = 0.5,\n              fov = 100,\n              shift_vertical = -300\n)\n\n# render\nrender_highquality(\n  filename = \"plot/oblique_nz.png\",\n  interactive = F,\n  lightdirection = 280, \n  lightaltitude = c(30, 80),\n  lightcolor = c('white', 'white'),  # Set both lights to white\n  lightintensity = c(600, 100),\n  width = 3000,\n  height = 3000,\n  samples = 200) #200\n\n# adjusting camera angle for top down view\nrender_camera(theta = 0,\n              phi = 89,\n              zoom = 0.5,\n              fov = 100,\n              shift_vertical = 0\n)\n\n# render\nrender_highquality(\n  filename = \"plot/top_down_nz.png\",\n  interactive = F,\n  lightdirection = 280, \n  lightaltitude = c(30, 80),\n  lightcolor = c('white', 'white'),  # Set both lights to white\n  lightintensity = c(600, 100),\n  width = 2000,\n  height = 3000,\n  samples = 200) # 200 \n\n# text colour \ntext_color <- colorspace::darken(color[3], .4)\ncolorspace::swatchplot(text_color)\n```\n\n```{.r .cell-code}\n# read file back in\ntop_down_nz <- image_read(\"plot/top_down_nz.png\")\n\n# add annotations\ntop_down_nz |> \n  image_annotate(\"New Zealand\",\n                 gravity = \"northeast\",\n                 location = \"+50+50\",\n                 color = text_color,\n                 size = 160,\n                 font = \"Philosopher\",\n                 weight = 700,\n  ) |> \n  image_annotate(\"2022 POPULATION DENSITY MAP\",\n                 gravity = \"northeast\",\n                 location = \"+50+195\",\n                 color = text_color,\n                 size = 50,\n                 font = \"Philosopher\",  # Corrected font name\n                 weight = 500,\n  ) |> \n  image_annotate(\"isaacbain.com\",\n                 gravity = \"southwest\",\n                 location = \"+20+20\",\n                 color = alpha(text_color, .8),\n                 font = \"Philosopher\",  # Corrected font name\n                 size = 35,\n  ) |> \n  image_write(\"plot/annotated_top_down_nz.png\", format = \"png\", quality = 100)\n\n# read file back in\noblique_nz <- image_read(\"plot/oblique_nz.png\")\n\n# crop, then add annotations\noblique_nz |> \n  image_crop(\n    \"2500x2500-0+500\"\n  ) |> \n  image_annotate(\"New Zealand\",\n                 gravity = \"northeast\",\n                 location = \"+50+50\",\n                 color = text_color,\n                 size = 160,\n                 font = \"Philosopher\",\n                 weight = 700,\n  ) |> \n  image_annotate(\"2022 POPULATION DENSITY MAP\",\n                 gravity = \"northeast\",\n                 location = \"+50+195\",\n                 color = text_color,\n                 size = 50,\n                 font = \"Philosopher\",  # Corrected font name\n                 weight = 500,\n  ) |> \n  image_annotate(\"isaacbain.com\",\n                 gravity = \"southwest\",\n                 location = \"+20+20\",\n                 color = alpha(text_color, .8),\n                 font = \"Philosopher\",  # Corrected font name\n                 size = 35,\n  ) |> \n  image_write(\"plot/annotated_oblique_nz.png\", format = \"png\", quality = 100)\n```\n:::\n\n\n## Results and interpretation\n\nCheck out these maps! They highlight where people are clustered, with taller spikes indicating higher population densities. You can clearly see urban centres like Auckland, Wellington, and Christchurch standing out, while rural areas have much shorter peaks.\n\n(click to zoom in)\n\n![](plot/annotated_top_down_nz.png){width=\"65%\"}\n\n![](plot/annotated_oblique_nz.png){width=\"65%\"}\n\n## Why 3D maps?\n\n-   Visual Appeal: Let’s be honest, they just look amazing. The 3D effect adds a whole new dimension (literally!) to the data.\n\n-   Easy to Understand: Even at a glance, you can see where the population is concentrated.\n\n-   Engaging: These maps can grab attention and spark interest in data that might otherwise seem dry.\n\n## Conclusion\n\n3D population density maps aren’t just for data geeks—they’re a fantastic way to make information visually appealing and accessible. Give `rayshader` a try if you’re into data visualisation. Who knew population data could look this good?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}